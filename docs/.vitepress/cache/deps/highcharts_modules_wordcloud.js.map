{
  "version": 3,
  "sources": ["../../../../node_modules/highcharts/modules/wordcloud.src.js"],
  "sourcesContent": ["/**\n * @license Highcharts JS v10.3.3 (2023-01-20)\n *\n * (c) 2016-2021 Highsoft AS\n * Authors: Jon Arild Nygard\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/wordcloud', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                window.dispatchEvent(\n                    new CustomEvent(\n                        'HighchartsModuleLoaded',\n                        { detail: { path: path, module: obj[path] }\n                    })\n                );\n            }\n        }\n    }\n    _registerModule(_modules, 'Series/DrawPointUtilities.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var isNumber = U.isNumber;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Handles the drawing of a component.\n         * Can be used for any type of component that reserves the graphic property,\n         * and provides a shouldDraw on its context.\n         *\n         * @private\n         *\n         * @todo add type checking.\n         * @todo export this function to enable usage\n         */\n        function draw(point, params) {\n            var animatableAttribs = params.animatableAttribs,\n                onComplete = params.onComplete,\n                css = params.css,\n                renderer = params.renderer;\n            var animation = (point.series && point.series.chart.hasRendered) ?\n                    // Chart-level animation on updates\n                    void 0 :\n                    // Series-level animation on new points\n                    (point.series &&\n                        point.series.options.animation);\n            var graphic = point.graphic;\n            params.attribs = params.attribs || {};\n            // Assigning class in dot notation does go well in IE8\n            // eslint-disable-next-line dot-notation\n            params.attribs['class'] = point.getClassName();\n            if ((point.shouldDraw())) {\n                if (!graphic) {\n                    point.graphic = graphic = params.shapeType === 'text' ?\n                        renderer.text() :\n                        renderer[params.shapeType](params.shapeArgs || {});\n                    graphic.add(params.group);\n                }\n                if (css) {\n                    graphic.css(css);\n                }\n                graphic\n                    .attr(params.attribs)\n                    .animate(animatableAttribs, params.isNew ? false : animation, onComplete);\n            }\n            else if (graphic) {\n                var destroy_1 = function () {\n                        point.graphic = graphic = (graphic && graphic.destroy());\n                    if (typeof onComplete === 'function') {\n                        onComplete();\n                    }\n                };\n                // animate only runs complete callback if something was animated.\n                if (Object.keys(animatableAttribs).length) {\n                    graphic.animate(animatableAttribs, void 0, function () { return destroy_1(); });\n                }\n                else {\n                    destroy_1();\n                }\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        var DrawPointUtilities = {\n                draw: draw\n            };\n\n        return DrawPointUtilities;\n    });\n    _registerModule(_modules, 'Series/Wordcloud/WordcloudPoint.js', [_modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (SeriesRegistry, U) {\n        /* *\n         *\n         *  Experimental Highcharts module which enables visualization of a word cloud.\n         *\n         *  (c) 2016-2021 Highsoft AS\n         *  Authors: Jon Arild Nygard\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var ColumnPoint = SeriesRegistry.seriesTypes.column.prototype.pointClass;\n        var extend = U.extend;\n        var WordcloudPoint = /** @class */ (function (_super) {\n                __extends(WordcloudPoint, _super);\n            function WordcloudPoint() {\n                /* *\n                 *\n                 * Properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                _this.dimensions = void 0;\n                _this.options = void 0;\n                _this.polygon = void 0;\n                _this.rect = void 0;\n                _this.series = void 0;\n                return _this;\n            }\n            /* *\n             *\n             * Functions\n             *\n             * */\n            WordcloudPoint.prototype.isValid = function () {\n                return true;\n            };\n            return WordcloudPoint;\n        }(ColumnPoint));\n        extend(WordcloudPoint.prototype, {\n            weight: 1\n        });\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return WordcloudPoint;\n    });\n    _registerModule(_modules, 'Series/Wordcloud/WordcloudUtils.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (H, U) {\n        /* *\n         *\n         *  Experimental Highcharts module which enables visualization of a word cloud.\n         *\n         *  (c) 2016-2021 Highsoft AS\n         *  Authors: Jon Arild Nygard\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         * */\n        var deg2rad = H.deg2rad;\n        var extend = U.extend,\n            find = U.find,\n            isNumber = U.isNumber,\n            isObject = U.isObject,\n            merge = U.merge;\n        /* *\n         *\n         * Functions\n         *\n         * */\n        /* eslint-disable valid-jsdoc */\n        /**\n         * Detects if there is a collision between two rectangles.\n         *\n         * @private\n         * @function isRectanglesIntersecting\n         *\n         * @param {Highcharts.PolygonBoxObject} r1\n         * First rectangle.\n         *\n         * @param {Highcharts.PolygonBoxObject} r2\n         * Second rectangle.\n         *\n         * @return {boolean}\n         * Returns true if the rectangles overlap.\n         */\n        function isRectanglesIntersecting(r1, r2) {\n            return !(r2.left > r1.right ||\n                r2.right < r1.left ||\n                r2.top > r1.bottom ||\n                r2.bottom < r1.top);\n        }\n        /**\n         * Calculates the normals to a line between two points.\n         *\n         * @private\n         * @function getNormals\n         * @param {Highcharts.PolygonPointObject} p1\n         *        Start point for the line. Array of x and y value.\n         * @param {Highcharts.PolygonPointObject} p2\n         *        End point for the line. Array of x and y value.\n         * @return {Highcharts.PolygonObject}\n         *         Returns the two normals in an array.\n         */\n        function getNormals(p1, p2) {\n            var dx = p2[0] - p1[0], // x2 - x1\n                dy = p2[1] - p1[1]; // y2 - y1\n                return [\n                    [-dy,\n                dx],\n                    [dy, -dx]\n                ];\n        }\n        /**\n         * @private\n         */\n        function getAxesFromPolygon(polygon) {\n            var points,\n                axes = polygon.axes || [];\n            if (!axes.length) {\n                axes = [];\n                points = points = polygon.concat([polygon[0]]);\n                points.reduce(function findAxis(p1, p2) {\n                    var normals = getNormals(p1,\n                        p2),\n                        axis = normals[0]; // Use the left normal as axis.\n                        // Check that the axis is unique.\n                        if (!find(axes,\n                        function (existing) {\n                            return existing[0] === axis[0] &&\n                                existing[1] === axis[1];\n                    })) {\n                        axes.push(axis);\n                    }\n                    // Return p2 to be used as p1 in next iteration.\n                    return p2;\n                });\n                polygon.axes = axes;\n            }\n            return axes;\n        }\n        /**\n         * Projects a polygon onto a coordinate.\n         *\n         * @private\n         * @function project\n         * @param {Highcharts.PolygonObject} polygon\n         * Array of points in a polygon.\n         * @param {Highcharts.PolygonPointObject} target\n         * The coordinate of pr\n         */\n        function project(polygon, target) {\n            var products = polygon.map(function (point) {\n                    var ax = point[0],\n                ay = point[1],\n                bx = target[0],\n                by = target[1];\n                return ax * bx + ay * by;\n            });\n            return {\n                min: Math.min.apply(this, products),\n                max: Math.max.apply(this, products)\n            };\n        }\n        /**\n         * @private\n         */\n        function isPolygonsOverlappingOnAxis(axis, polygon1, polygon2) {\n            var projection1 = project(polygon1,\n                axis),\n                projection2 = project(polygon2,\n                axis),\n                isOverlapping = !(projection2.min > projection1.max ||\n                    projection2.max < projection1.min);\n            return !isOverlapping;\n        }\n        /**\n         * Checks whether two convex polygons are colliding by using the Separating\n         * Axis Theorem.\n         *\n         * @private\n         * @function isPolygonsColliding\n         * @param {Highcharts.PolygonObject} polygon1\n         *        First polygon.\n         *\n         * @param {Highcharts.PolygonObject} polygon2\n         *        Second polygon.\n         *\n         * @return {boolean}\n         *         Returns true if they are colliding, otherwise false.\n         */\n        function isPolygonsColliding(polygon1, polygon2) {\n            // Get the axis from both polygons.\n            var axes1 = getAxesFromPolygon(polygon1),\n                axes2 = getAxesFromPolygon(polygon2),\n                axes = axes1.concat(axes2),\n                overlappingOnAllAxes = !find(axes,\n                function (axis) { return isPolygonsOverlappingOnAxis(axis,\n                polygon1,\n                polygon2); });\n            return overlappingOnAllAxes;\n        }\n        /**\n         * Detects if a word collides with any previously placed words.\n         *\n         * @private\n         * @function intersectsAnyWord\n         *\n         * @param {Highcharts.Point} point\n         * Point which the word is connected to.\n         *\n         * @param {Array<Highcharts.Point>} points\n         * Previously placed points to check against.\n         *\n         * @return {boolean}\n         * Returns true if there is collision.\n         */\n        function intersectsAnyWord(point, points) {\n            var intersects = false,\n                rect = point.rect,\n                polygon = point.polygon,\n                lastCollidedWith = point.lastCollidedWith,\n                isIntersecting = function (p) {\n                    var result = isRectanglesIntersecting(rect,\n                p.rect);\n                if (result &&\n                    (point.rotation % 90 || p.rotation % 90)) {\n                    result = isPolygonsColliding(polygon, p.polygon);\n                }\n                return result;\n            };\n            // If the point has already intersected a different point, chances are\n            // they are still intersecting. So as an enhancement we check this\n            // first.\n            if (lastCollidedWith) {\n                intersects = isIntersecting(lastCollidedWith);\n                // If they no longer intersects, remove the cache from the point.\n                if (!intersects) {\n                    delete point.lastCollidedWith;\n                }\n            }\n            // If not already found, then check if we can find a point that is\n            // intersecting.\n            if (!intersects) {\n                intersects = !!find(points, function (p) {\n                    var result = isIntersecting(p);\n                    if (result) {\n                        point.lastCollidedWith = p;\n                    }\n                    return result;\n                });\n            }\n            return intersects;\n        }\n        /**\n         * Gives a set of cordinates for an Archimedian Spiral.\n         *\n         * @private\n         * @function archimedeanSpiral\n         *\n         * @param {number} attempt\n         * How far along the spiral we have traversed.\n         *\n         * @param {Highcharts.WordcloudSpiralParamsObject} [params]\n         * Additional parameters.\n         *\n         * @return {boolean|Highcharts.PositionObject}\n         * Resulting coordinates, x and y. False if the word should be dropped from\n         * the visualization.\n         */\n        function archimedeanSpiral(attempt, params) {\n            var field = params.field,\n                result = false,\n                maxDelta = (field.width * field.width) + (field.height * field.height),\n                t = attempt * 0.8; // 0.2 * 4 = 0.8. Enlarging the spiral.\n                // Emergency brake. TODO make spiralling logic more foolproof.\n                if (attempt <= 10000) {\n                    result = {\n                        x: t * Math.cos(t),\n                        y: t * Math.sin(t)\n                    };\n                if (!(Math.min(Math.abs(result.x), Math.abs(result.y)) < maxDelta)) {\n                    result = false;\n                }\n            }\n            return result;\n        }\n        /**\n         * Gives a set of cordinates for an rectangular spiral.\n         *\n         * @private\n         * @function squareSpiral\n         *\n         * @param {number} attempt\n         * How far along the spiral we have traversed.\n         *\n         * @param {Highcharts.WordcloudSpiralParamsObject} [params]\n         * Additional parameters.\n         *\n         * @return {boolean|Highcharts.PositionObject}\n         * Resulting coordinates, x and y. False if the word should be dropped from\n         * the visualization.\n         */\n        function squareSpiral(attempt, params) {\n            var a = attempt * 4,\n                k = Math.ceil((Math.sqrt(a) - 1) / 2),\n                t = 2 * k + 1,\n                m = Math.pow(t, 2),\n                isBoolean = function (x) {\n                    return typeof x === 'boolean';\n            }, result = false;\n            t -= 1;\n            if (attempt <= 10000) {\n                if (isBoolean(result) && a >= m - t) {\n                    result = {\n                        x: k - (m - a),\n                        y: -k\n                    };\n                }\n                m -= t;\n                if (isBoolean(result) && a >= m - t) {\n                    result = {\n                        x: -k,\n                        y: -k + (m - a)\n                    };\n                }\n                m -= t;\n                if (isBoolean(result)) {\n                    if (a >= m - t) {\n                        result = {\n                            x: -k + (m - a),\n                            y: k\n                        };\n                    }\n                    else {\n                        result = {\n                            x: k,\n                            y: k - (m - a - t)\n                        };\n                    }\n                }\n                result.x *= 5;\n                result.y *= 5;\n            }\n            return result;\n        }\n        /**\n         * Gives a set of cordinates for an rectangular spiral.\n         *\n         * @private\n         * @function rectangularSpiral\n         *\n         * @param {number} attempt\n         * How far along the spiral we have traversed.\n         *\n         * @param {Highcharts.WordcloudSpiralParamsObject} [params]\n         * Additional parameters.\n         *\n         * @return {boolean|Higcharts.PositionObject}\n         * Resulting coordinates, x and y. False if the word should be dropped from\n         * the visualization.\n         */\n        function rectangularSpiral(attempt, params) {\n            var result = squareSpiral(attempt,\n                params),\n                field = params.field;\n            if (result) {\n                result.x *= field.ratioX;\n                result.y *= field.ratioY;\n            }\n            return result;\n        }\n        /**\n         * @private\n         * @function getRandomPosition\n         *\n         * @param {number} size\n         * Random factor.\n         *\n         * @return {number}\n         * Random position.\n         */\n        function getRandomPosition(size) {\n            return Math.round((size * (Math.random() + 0.5)) / 2);\n        }\n        /**\n         * Calculates the proper scale to fit the cloud inside the plotting area.\n         *\n         * @private\n         * @function getScale\n         *\n         * @param {number} targetWidth\n         * Width of target area.\n         *\n         * @param {number} targetHeight\n         * Height of target area.\n         *\n         * @param {Object} field\n         * The playing field.\n         *\n         * @param {Highcharts.Series} series\n         * Series object.\n         *\n         * @return {number}\n         * Returns the value to scale the playing field up to the size of the target\n         * area.\n         */\n        function getScale(targetWidth, targetHeight, field) {\n            var height = Math.max(Math.abs(field.top),\n                Math.abs(field.bottom)) * 2,\n                width = Math.max(Math.abs(field.left),\n                Math.abs(field.right)) * 2,\n                scaleX = width > 0 ? 1 / width * targetWidth : 1,\n                scaleY = height > 0 ? 1 / height * targetHeight : 1;\n            return Math.min(scaleX, scaleY);\n        }\n        /**\n         * Calculates what is called the playing field. The field is the area which\n         * all the words are allowed to be positioned within. The area is\n         * proportioned to match the target aspect ratio.\n         *\n         * @private\n         * @function getPlayingField\n         *\n         * @param {number} targetWidth\n         * Width of the target area.\n         *\n         * @param {number} targetHeight\n         * Height of the target area.\n         *\n         * @param {Array<Highcharts.Point>} data\n         * Array of points.\n         *\n         * @param {Object} data.dimensions\n         * The height and width of the word.\n         *\n         * @return {Object}\n         * The width and height of the playing field.\n         */\n        function getPlayingField(targetWidth, targetHeight, data) {\n            var info = data.reduce(function (obj,\n                point) {\n                    var dimensions = point.dimensions,\n                x = Math.max(dimensions.width,\n                dimensions.height);\n                // Find largest height.\n                obj.maxHeight = Math.max(obj.maxHeight, dimensions.height);\n                // Find largest width.\n                obj.maxWidth = Math.max(obj.maxWidth, dimensions.width);\n                // Sum up the total maximum area of all the words.\n                obj.area += x * x;\n                return obj;\n            }, {\n                maxHeight: 0,\n                maxWidth: 0,\n                area: 0\n            }), \n            /**\n             * Use largest width, largest height, or root of total area to give\n             * size to the playing field.\n             */\n            x = Math.max(info.maxHeight, // Have enough space for the tallest word\n            info.maxWidth, // Have enough space for the broadest word\n            // Adjust 15% to account for close packing of words\n            Math.sqrt(info.area) * 0.85), ratioX = targetWidth > targetHeight ? targetWidth / targetHeight : 1, ratioY = targetHeight > targetWidth ? targetHeight / targetWidth : 1;\n            return {\n                width: x * ratioX,\n                height: x * ratioY,\n                ratioX: ratioX,\n                ratioY: ratioY\n            };\n        }\n        /**\n         * Calculates a number of degrees to rotate, based upon a number of\n         * orientations within a range from-to.\n         *\n         * @private\n         * @function getRotation\n         *\n         * @param {number} [orientations]\n         * Number of orientations.\n         *\n         * @param {number} [index]\n         * Index of point, used to decide orientation.\n         *\n         * @param {number} [from]\n         * The smallest degree of rotation.\n         *\n         * @param {number} [to]\n         * The largest degree of rotation.\n         *\n         * @return {boolean|number}\n         * Returns the resulting rotation for the word. Returns false if invalid\n         * input parameters.\n         */\n        function getRotation(orientations, index, from, to) {\n            var result = false, // Default to false\n                range,\n                intervals,\n                orientation;\n            // Check if we have valid input parameters.\n            if (isNumber(orientations) &&\n                isNumber(index) &&\n                isNumber(from) &&\n                isNumber(to) &&\n                orientations > 0 &&\n                index > -1 &&\n                to > from) {\n                range = to - from;\n                intervals = range / (orientations - 1 || 1);\n                orientation = index % orientations;\n                result = from + (orientation * intervals);\n            }\n            return result;\n        }\n        /**\n         * Calculates the spiral positions and store them in scope for quick access.\n         *\n         * @private\n         * @function getSpiral\n         *\n         * @param {Function} fn\n         * The spiral function.\n         *\n         * @param {Object} params\n         * Additional parameters for the spiral.\n         *\n         * @return {Function}\n         * Function with access to spiral positions.\n         */\n        function getSpiral(fn, params) {\n            var length = 10000,\n                i,\n                arr = [];\n            for (i = 1; i < length; i++) {\n                // @todo unnecessary amount of precaclulation\n                arr.push(fn(i, params));\n            }\n            return function (attempt) {\n                return attempt <= length ? arr[attempt - 1] : false;\n            };\n        }\n        /**\n         * Detects if a word is placed outside the playing field.\n         *\n         * @private\n         * @function outsidePlayingField\n         *\n         * @param {Highcharts.PolygonBoxObject} rect\n         * The word box.\n         *\n         * @param {Highcharts.WordcloudFieldObject} field\n         * The width and height of the playing field.\n         *\n         * @return {boolean}\n         * Returns true if the word is placed outside the field.\n         */\n        function outsidePlayingField(rect, field) {\n            var playingField = {\n                    left: -(field.width / 2),\n                    right: field.width / 2,\n                    top: -(field.height / 2),\n                    bottom: field.height / 2\n                };\n            return !(playingField.left < rect.left &&\n                playingField.right > rect.right &&\n                playingField.top < rect.top &&\n                playingField.bottom > rect.bottom);\n        }\n        /**\n         * @private\n         */\n        function movePolygon(deltaX, deltaY, polygon) {\n            return polygon.map(function (point) {\n                return [\n                    point[0] + deltaX,\n                    point[1] + deltaY\n                ];\n            });\n        }\n        /**\n         * Check if a point intersects with previously placed words, or if it goes\n         * outside the field boundaries. If a collision, then try to adjusts the\n         * position.\n         *\n         * @private\n         * @function intersectionTesting\n         *\n         * @param {Highcharts.Point} point\n         * Point to test for intersections.\n         *\n         * @param {Highcharts.WordcloudTestOptionsObject} options\n         * Options object.\n         *\n         * @return {boolean|Highcharts.PositionObject}\n         * Returns an object with how much to correct the positions. Returns false\n         * if the word should not be placed at all.\n         */\n        function intersectionTesting(point, options) {\n            var placed = options.placed,\n                field = options.field,\n                rectangle = options.rectangle,\n                polygon = options.polygon,\n                spiral = options.spiral,\n                attempt = 1,\n                delta = {\n                    x: 0,\n                    y: 0\n                }, \n                // Make a copy to update values during intersection testing.\n                rect = point.rect = extend({},\n                rectangle);\n            point.polygon = polygon;\n            point.rotation = options.rotation;\n            /* while w intersects any previously placed words:\n                do {\n                move w a little bit along a spiral path\n                } while any part of w is outside the playing field and\n                        the spiral radius is still smallish */\n            while (delta !== false &&\n                (intersectsAnyWord(point, placed) ||\n                    outsidePlayingField(rect, field))) {\n                delta = spiral(attempt);\n                if (isObject(delta)) {\n                    // Update the DOMRect with new positions.\n                    rect.left = rectangle.left + delta.x;\n                    rect.right = rectangle.right + delta.x;\n                    rect.top = rectangle.top + delta.y;\n                    rect.bottom = rectangle.bottom + delta.y;\n                    point.polygon = movePolygon(delta.x, delta.y, polygon);\n                }\n                attempt++;\n            }\n            return delta;\n        }\n        /**\n         * Extends the playing field to have enough space to fit a given word.\n         *\n         * @private\n         * @function extendPlayingField\n         *\n         * @param {Highcharts.WordcloudFieldObject} field\n         * The width, height and ratios of a playing field.\n         *\n         * @param {Highcharts.PolygonBoxObject} rectangle\n         * The bounding box of the word to add space for.\n         *\n         * @return {Highcharts.WordcloudFieldObject}\n         * Returns the extended playing field with updated height and width.\n         */\n        function extendPlayingField(field, rectangle) {\n            var height,\n                width,\n                ratioX,\n                ratioY,\n                x,\n                extendWidth,\n                extendHeight,\n                result;\n            if (isObject(field) && isObject(rectangle)) {\n                height = (rectangle.bottom - rectangle.top);\n                width = (rectangle.right - rectangle.left);\n                ratioX = field.ratioX;\n                ratioY = field.ratioY;\n                // Use the same variable to extend both the height and width.\n                x = ((width * ratioX) > (height * ratioY)) ? width : height;\n                // Multiply variable with ratios to preserve aspect ratio.\n                extendWidth = x * ratioX;\n                extendHeight = x * ratioY;\n                // Calculate the size of the new field after adding\n                // space for the word.\n                result = merge(field, {\n                    // Add space on the left and right.\n                    width: field.width + (extendWidth * 2),\n                    // Add space on the top and bottom.\n                    height: field.height + (extendHeight * 2)\n                });\n            }\n            else {\n                result = field;\n            }\n            // Return the new extended field.\n            return result;\n        }\n        /**\n         * If a rectangle is outside a give field, then the boundaries of the field\n         * is adjusted accordingly. Modifies the field object which is passed as the\n         * first parameter.\n         *\n         * @private\n         * @function updateFieldBoundaries\n         *\n         * @param {Highcharts.WordcloudFieldObject} field\n         * The bounding box of a playing field.\n         *\n         * @param {Highcharts.PolygonBoxObject} rectangle\n         * The bounding box for a placed point.\n         *\n         * @return {Highcharts.WordcloudFieldObject}\n         * Returns a modified field object.\n         */\n        function updateFieldBoundaries(field, rectangle) {\n            // @todo improve type checking.\n            if (!isNumber(field.left) || field.left > rectangle.left) {\n                field.left = rectangle.left;\n            }\n            if (!isNumber(field.right) || field.right < rectangle.right) {\n                field.right = rectangle.right;\n            }\n            if (!isNumber(field.top) || field.top > rectangle.top) {\n                field.top = rectangle.top;\n            }\n            if (!isNumber(field.bottom) || field.bottom < rectangle.bottom) {\n                field.bottom = rectangle.bottom;\n            }\n            return field;\n        }\n        /**\n         * Alternative solution to correctFloat.\n         * E.g Highcharts.correctFloat(123, 2) returns 120, when it should be 123.\n         *\n         * @private\n         * @function correctFloat\n         */\n        function correctFloat(number, precision) {\n            var p = isNumber(precision) ? precision : 14,\n                magnitude = Math.pow(10,\n                p);\n            return Math.round(number * magnitude) / magnitude;\n        }\n        /**\n         * @private\n         */\n        function getBoundingBoxFromPolygon(points) {\n            return points.reduce(function (obj, point) {\n                var x = point[0],\n                    y = point[1];\n                obj.left = Math.min(x, obj.left);\n                obj.right = Math.max(x, obj.right);\n                obj.bottom = Math.max(y, obj.bottom);\n                obj.top = Math.min(y, obj.top);\n                return obj;\n            }, {\n                left: Number.MAX_VALUE,\n                right: -Number.MAX_VALUE,\n                bottom: -Number.MAX_VALUE,\n                top: Number.MAX_VALUE\n            });\n        }\n        /**\n         * @private\n         */\n        function getPolygon(x, y, width, height, rotation) {\n            var origin = [x,\n                y],\n                left = x - (width / 2),\n                right = x + (width / 2),\n                top = y - (height / 2),\n                bottom = y + (height / 2),\n                polygon = [\n                    [left,\n                top],\n                    [right,\n                top],\n                    [right,\n                bottom],\n                    [left,\n                bottom]\n                ];\n            return polygon.map(function (point) {\n                return rotate2DToPoint(point, origin, -rotation);\n            });\n        }\n        /**\n         * Rotates a point clockwise around the origin.\n         *\n         * @private\n         * @function rotate2DToOrigin\n         * @param {Highcharts.PolygonPointObject} point\n         *        The x and y coordinates for the point.\n         * @param {number} angle\n         *        The angle of rotation.\n         * @return {Highcharts.PolygonPointObject}\n         *         The x and y coordinate for the rotated point.\n         */\n        function rotate2DToOrigin(point, angle) {\n            var x = point[0],\n                y = point[1],\n                rad = deg2rad * -angle,\n                cosAngle = Math.cos(rad),\n                sinAngle = Math.sin(rad);\n            return [\n                correctFloat(x * cosAngle - y * sinAngle),\n                correctFloat(x * sinAngle + y * cosAngle)\n            ];\n        }\n        /**\n         * Rotate a point clockwise around another point.\n         *\n         * @private\n         * @function rotate2DToPoint\n         * @param {Highcharts.PolygonPointObject} point\n         *        The x and y coordinates for the point.\n         * @param {Highcharts.PolygonPointObject} origin\n         *        The point to rotate around.\n         * @param {number} angle\n         *        The angle of rotation.\n         * @return {Highcharts.PolygonPointObject}\n         *         The x and y coordinate for the rotated point.\n         */\n        function rotate2DToPoint(point, origin, angle) {\n            var x = point[0] - origin[0],\n                y = point[1] - origin[1],\n                rotated = rotate2DToOrigin([x,\n                y],\n                angle);\n            return [\n                rotated[0] + origin[0],\n                rotated[1] + origin[1]\n            ];\n        }\n        /* *\n         *\n         * Default export\n         *\n         * */\n        var WordcloudUtils = {\n                archimedeanSpiral: archimedeanSpiral,\n                extendPlayingField: extendPlayingField,\n                getBoundingBoxFromPolygon: getBoundingBoxFromPolygon,\n                getPlayingField: getPlayingField,\n                getPolygon: getPolygon,\n                getRandomPosition: getRandomPosition,\n                getRotation: getRotation,\n                getScale: getScale,\n                getSpiral: getSpiral,\n                intersectionTesting: intersectionTesting,\n                isPolygonsColliding: isPolygonsColliding,\n                isRectanglesIntersecting: isRectanglesIntersecting,\n                rectangularSpiral: rectangularSpiral,\n                rotate2DToOrigin: rotate2DToOrigin,\n                rotate2DToPoint: rotate2DToPoint,\n                squareSpiral: squareSpiral,\n                updateFieldBoundaries: updateFieldBoundaries\n            };\n\n        return WordcloudUtils;\n    });\n    _registerModule(_modules, 'Series/Wordcloud/WordcloudSeries.js', [_modules['Series/DrawPointUtilities.js'], _modules['Core/Globals.js'], _modules['Core/Series/Series.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js'], _modules['Series/Wordcloud/WordcloudPoint.js'], _modules['Series/Wordcloud/WordcloudUtils.js']], function (DPU, H, Series, SeriesRegistry, U, WordcloudPoint, WordcloudUtils) {\n        /* *\n         *\n         *  Experimental Highcharts module which enables visualization of a word cloud.\n         *\n         *  (c) 2016-2021 Highsoft AS\n         *  Authors: Jon Arild Nygard\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var noop = H.noop;\n        var ColumnSeries = SeriesRegistry.seriesTypes.column;\n        var extend = U.extend,\n            isArray = U.isArray,\n            isNumber = U.isNumber,\n            isObject = U.isObject,\n            merge = U.merge;\n        var archimedeanSpiral = WordcloudUtils.archimedeanSpiral,\n            extendPlayingField = WordcloudUtils.extendPlayingField,\n            getBoundingBoxFromPolygon = WordcloudUtils.getBoundingBoxFromPolygon,\n            getPlayingField = WordcloudUtils.getPlayingField,\n            getPolygon = WordcloudUtils.getPolygon,\n            getRandomPosition = WordcloudUtils.getRandomPosition,\n            getRotation = WordcloudUtils.getRotation,\n            getScale = WordcloudUtils.getScale,\n            getSpiral = WordcloudUtils.getSpiral,\n            intersectionTesting = WordcloudUtils.intersectionTesting,\n            isPolygonsColliding = WordcloudUtils.isPolygonsColliding,\n            rectangularSpiral = WordcloudUtils.rectangularSpiral,\n            rotate2DToOrigin = WordcloudUtils.rotate2DToOrigin,\n            rotate2DToPoint = WordcloudUtils.rotate2DToPoint,\n            squareSpiral = WordcloudUtils.squareSpiral,\n            updateFieldBoundaries = WordcloudUtils.updateFieldBoundaries;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.wordcloud\n         *\n         * @augments Highcharts.Series\n         */\n        var WordcloudSeries = /** @class */ (function (_super) {\n                __extends(WordcloudSeries, _super);\n            function WordcloudSeries() {\n                /* *\n                 *\n                 * Static properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                /* *\n                 *\n                 * Properties\n                 *\n                 * */\n                _this.data = void 0;\n                _this.options = void 0;\n                _this.points = void 0;\n                return _this;\n            }\n            /**\n             *\n             * Functions\n             *\n             */\n            WordcloudSeries.prototype.bindAxes = function () {\n                var wordcloudAxis = {\n                        endOnTick: false,\n                        gridLineWidth: 0,\n                        lineWidth: 0,\n                        maxPadding: 0,\n                        startOnTick: false,\n                        title: void 0,\n                        tickPositions: []\n                    };\n                Series.prototype.bindAxes.call(this);\n                extend(this.yAxis.options, wordcloudAxis);\n                extend(this.xAxis.options, wordcloudAxis);\n            };\n            WordcloudSeries.prototype.pointAttribs = function (point, state) {\n                var attribs = H.seriesTypes.column.prototype\n                        .pointAttribs.call(this,\n                    point,\n                    state);\n                delete attribs.stroke;\n                delete attribs['stroke-width'];\n                return attribs;\n            };\n            /**\n             * Calculates the fontSize of a word based on its weight.\n             *\n             * @private\n             * @function Highcharts.Series#deriveFontSize\n             *\n             * @param {number} [relativeWeight=0]\n             * The weight of the word, on a scale 0-1.\n             *\n             * @param {number} [maxFontSize=1]\n             * The maximum font size of a word.\n             *\n             * @param {number} [minFontSize=1]\n             * The minimum font size of a word.\n             *\n             * @return {number}\n             * Returns the resulting fontSize of a word. If minFontSize is larger then\n             * maxFontSize the result will equal minFontSize.\n             */\n            WordcloudSeries.prototype.deriveFontSize = function (relativeWeight, maxFontSize, minFontSize) {\n                var weight = isNumber(relativeWeight) ? relativeWeight : 0,\n                    max = isNumber(maxFontSize) ? maxFontSize : 1,\n                    min = isNumber(minFontSize) ? minFontSize : 1;\n                return Math.floor(Math.max(min, weight * max));\n            };\n            WordcloudSeries.prototype.drawPoints = function () {\n                var series = this,\n                    hasRendered = series.hasRendered,\n                    xAxis = series.xAxis,\n                    yAxis = series.yAxis,\n                    chart = series.chart,\n                    group = series.group,\n                    options = series.options,\n                    animation = options.animation,\n                    allowExtendPlayingField = options.allowExtendPlayingField,\n                    renderer = chart.renderer,\n                    testElement = renderer.text().add(group),\n                    placed = [],\n                    placementStrategy = series.placementStrategy[options.placementStrategy],\n                    spiral,\n                    rotation = options.rotation,\n                    scale,\n                    weights = series.points.map(function (p) {\n                        return p.weight;\n                }), maxWeight = Math.max.apply(null, weights), \n                // concat() prevents from sorting the original array.\n                data = series.points.concat().sort(function (a, b) {\n                    return b.weight - a.weight; // Sort descending\n                }), field;\n                // Reset the scale before finding the dimensions (#11993).\n                // SVGGRaphicsElement.getBBox() (used in SVGElement.getBBox(boolean))\n                // returns slightly different values for the same element depending on\n                // whether it is rendered in a group which has already defined scale\n                // (e.g. 6) or in the group without a scale (scale = 1).\n                series.group.attr({\n                    scaleX: 1,\n                    scaleY: 1\n                });\n                // Get the dimensions for each word.\n                // Used in calculating the playing field.\n                data.forEach(function (point) {\n                    var relativeWeight = 1 / maxWeight * point.weight,\n                        fontSize = series.deriveFontSize(relativeWeight,\n                        options.maxFontSize,\n                        options.minFontSize),\n                        css = extend({\n                            fontSize: fontSize + 'px'\n                        },\n                        options.style),\n                        bBox;\n                    testElement.css(css).attr({\n                        x: 0,\n                        y: 0,\n                        text: point.name\n                    });\n                    bBox = testElement.getBBox(true);\n                    point.dimensions = {\n                        height: bBox.height,\n                        width: bBox.width\n                    };\n                });\n                // Calculate the playing field.\n                field = getPlayingField(xAxis.len, yAxis.len, data);\n                spiral = getSpiral(series.spirals[options.spiral], {\n                    field: field\n                });\n                // Draw all the points.\n                data.forEach(function (point) {\n                    var relativeWeight = 1 / maxWeight * point.weight,\n                        fontSize = series.deriveFontSize(relativeWeight,\n                        options.maxFontSize,\n                        options.minFontSize),\n                        css = extend({\n                            fontSize: fontSize + 'px'\n                        },\n                        options.style),\n                        placement = placementStrategy(point, {\n                            data: data,\n                            field: field,\n                            placed: placed,\n                            rotation: rotation\n                        }),\n                        attr = extend(series.pointAttribs(point, (point.selected && 'select')), {\n                            align: 'center',\n                            'alignment-baseline': 'middle',\n                            'dominant-baseline': 'middle',\n                            x: placement.x,\n                            y: placement.y,\n                            text: point.name,\n                            rotation: isNumber(placement.rotation) ?\n                                placement.rotation :\n                                void 0\n                        }),\n                        polygon = getPolygon(placement.x,\n                        placement.y,\n                        point.dimensions.width,\n                        point.dimensions.height,\n                        placement.rotation),\n                        rectangle = getBoundingBoxFromPolygon(polygon),\n                        delta = intersectionTesting(point, {\n                            rectangle: rectangle,\n                            polygon: polygon,\n                            field: field,\n                            placed: placed,\n                            spiral: spiral,\n                            rotation: placement.rotation\n                        }),\n                        animate;\n                    // If there is no space for the word, extend the playing field.\n                    if (!delta && allowExtendPlayingField) {\n                        // Extend the playing field to fit the word.\n                        field = extendPlayingField(field, rectangle);\n                        // Run intersection testing one more time to place the word.\n                        delta = intersectionTesting(point, {\n                            rectangle: rectangle,\n                            polygon: polygon,\n                            field: field,\n                            placed: placed,\n                            spiral: spiral,\n                            rotation: placement.rotation\n                        });\n                    }\n                    // Check if point was placed, if so delete it, otherwise place it\n                    // on the correct positions.\n                    if (isObject(delta)) {\n                        attr.x = (attr.x || 0) + delta.x;\n                        attr.y = (attr.y || 0) + delta.y;\n                        rectangle.left += delta.x;\n                        rectangle.right += delta.x;\n                        rectangle.top += delta.y;\n                        rectangle.bottom += delta.y;\n                        field = updateFieldBoundaries(field, rectangle);\n                        placed.push(point);\n                        point.isNull = false;\n                        point.isInside = true; // #15447\n                    }\n                    else {\n                        point.isNull = true;\n                    }\n                    if (animation) {\n                        // Animate to new positions\n                        animate = {\n                            x: attr.x,\n                            y: attr.y\n                        };\n                        // Animate from center of chart\n                        if (!hasRendered) {\n                            attr.x = 0;\n                            attr.y = 0;\n                            // or animate from previous position\n                        }\n                        else {\n                            delete attr.x;\n                            delete attr.y;\n                        }\n                    }\n                    DPU.draw(point, {\n                        animatableAttribs: animate,\n                        attribs: attr,\n                        css: css,\n                        group: group,\n                        renderer: renderer,\n                        shapeArgs: void 0,\n                        shapeType: 'text'\n                    });\n                });\n                // Destroy the element after use.\n                testElement = testElement.destroy();\n                // Scale the series group to fit within the plotArea.\n                scale = getScale(xAxis.len, yAxis.len, field);\n                series.group.attr({\n                    scaleX: scale,\n                    scaleY: scale\n                });\n            };\n            WordcloudSeries.prototype.hasData = function () {\n                var series = this;\n                return (isObject(series) &&\n                    series.visible === true &&\n                    isArray(series.points) &&\n                    series.points.length > 0);\n            };\n            WordcloudSeries.prototype.getPlotBox = function () {\n                var series = this, chart = series.chart, inverted = chart.inverted, \n                    // Swap axes for inverted (#2339)\n                    xAxis = series[(inverted ? 'yAxis' : 'xAxis')], yAxis = series[(inverted ? 'xAxis' : 'yAxis')], width = xAxis ? xAxis.len : chart.plotWidth, height = yAxis ? yAxis.len : chart.plotHeight, x = xAxis ? xAxis.left : chart.plotLeft, y = yAxis ? yAxis.top : chart.plotTop;\n                return {\n                    translateX: x + (width / 2),\n                    translateY: y + (height / 2),\n                    scaleX: 1,\n                    scaleY: 1\n                };\n            };\n            /**\n             * A word cloud is a visualization of a set of words, where the size and\n             * placement of a word is determined by how it is weighted.\n             *\n             * @sample highcharts/demo/wordcloud Word Cloud chart\n             *\n             * @extends      plotOptions.column\n             * @excluding    allAreas, boostThreshold, clip, colorAxis, compare,\n             *               compareBase, crisp, cropThreshold, dataGrouping,\n             *               dataLabels, depth, dragDrop, edgeColor, findNearestPointBy,\n             *               getExtremesFromAll, grouping, groupPadding, groupZPadding,\n             *               joinBy, maxPointWidth, minPointLength, navigatorOptions,\n             *               negativeColor, pointInterval, pointIntervalUnit,\n             *               pointPadding, pointPlacement, pointRange, pointStart,\n             *               pointWidth, pointStart, pointWidth, shadow, showCheckbox,\n             *               showInNavigator, softThreshold, stacking, threshold,\n             *               zoneAxis, zones, dataSorting, boostBlending\n             * @product      highcharts\n             * @since        6.0.0\n             * @requires     modules/wordcloud\n             * @optionparent plotOptions.wordcloud\n             */\n            WordcloudSeries.defaultOptions = merge(ColumnSeries.defaultOptions, {\n                /**\n                 * If there is no space for a word on the playing field, then this\n                 * option will allow the playing field to be extended to fit the word.\n                 * If false then the word will be dropped from the visualization.\n                 *\n                 * NB! This option is currently not decided to be published in the API,\n                 * and is therefore marked as private.\n                 *\n                 * @ignore-option\n                 */\n                allowExtendPlayingField: true,\n                animation: {\n                    /** @internal */\n                    duration: 500\n                },\n                borderWidth: 0,\n                /**\n                 * @ignore-option\n                 */\n                clip: false,\n                colorByPoint: true,\n                cropThreshold: Infinity,\n                /**\n                 * A threshold determining the minimum font size that can be applied to\n                 * a word.\n                 */\n                minFontSize: 1,\n                /**\n                 * The word with the largest weight will have a font size equal to this\n                 * value. The font size of a word is the ratio between its weight and\n                 * the largest occuring weight, multiplied with the value of\n                 * maxFontSize.\n                 */\n                maxFontSize: 25,\n                /**\n                 * This option decides which algorithm is used for placement, and\n                 * rotation of a word. The choice of algorith is therefore a crucial\n                 * part of the resulting layout of the wordcloud. It is possible for\n                 * users to add their own custom placement strategies for use in word\n                 * cloud. Read more about it in our\n                 * [documentation](https://www.highcharts.com/docs/chart-and-series-types/word-cloud-series#custom-placement-strategies)\n                 *\n                 * @validvalue [\"center\", \"random\"]\n                 */\n                placementStrategy: 'center',\n                /**\n                 * Rotation options for the words in the wordcloud.\n                 *\n                 * @sample highcharts/plotoptions/wordcloud-rotation\n                 *         Word cloud with rotation\n                 */\n                rotation: {\n                    /**\n                     * The smallest degree of rotation for a word.\n                     */\n                    from: 0,\n                    /**\n                     * The number of possible orientations for a word, within the range\n                     * of `rotation.from` and `rotation.to`. Must be a number larger\n                     * than 0.\n                     */\n                    orientations: 2,\n                    /**\n                     * The largest degree of rotation for a word.\n                     */\n                    to: 90\n                },\n                showInLegend: false,\n                /**\n                 * Spiral used for placing a word after the initial position\n                 * experienced a collision with either another word or the borders.\n                 * It is possible for users to add their own custom spiralling\n                 * algorithms for use in word cloud. Read more about it in our\n                 * [documentation](https://www.highcharts.com/docs/chart-and-series-types/word-cloud-series#custom-spiralling-algorithm)\n                 *\n                 * @validvalue [\"archimedean\", \"rectangular\", \"square\"]\n                 */\n                spiral: 'rectangular',\n                /**\n                 * CSS styles for the words.\n                 *\n                 * @type    {Highcharts.CSSObject}\n                 * @default {\"fontFamily\":\"sans-serif\", \"fontWeight\": \"900\"}\n                 */\n                style: {\n                    /** @ignore-option */\n                    fontFamily: 'sans-serif',\n                    /** @ignore-option */\n                    fontWeight: '900',\n                    /** @ignore-option */\n                    whiteSpace: 'nowrap'\n                },\n                tooltip: {\n                    followPointer: true,\n                    pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.weight}</b><br/>'\n                }\n            });\n            return WordcloudSeries;\n        }(ColumnSeries));\n        extend(WordcloudSeries.prototype, {\n            animate: noop,\n            animateDrilldown: noop,\n            animateDrillupFrom: noop,\n            pointClass: WordcloudPoint,\n            setClip: noop,\n            // Strategies used for deciding rotation and initial position of a word. To\n            // implement a custom strategy, have a look at the function random for\n            // example.\n            placementStrategy: {\n                random: function (point, options) {\n                    var field = options.field,\n                        r = options.rotation;\n                    return {\n                        x: getRandomPosition(field.width) - (field.width / 2),\n                        y: getRandomPosition(field.height) - (field.height / 2),\n                        rotation: getRotation(r.orientations, point.index, r.from, r.to)\n                    };\n                },\n                center: function (point, options) {\n                    var r = options.rotation;\n                    return {\n                        x: 0,\n                        y: 0,\n                        rotation: getRotation(r.orientations, point.index, r.from, r.to)\n                    };\n                }\n            },\n            pointArrayMap: ['weight'],\n            // Spirals used for placing a word after the initial position experienced a\n            // collision with either another word or the borders. To implement a custom\n            // spiral, look at the function archimedeanSpiral for example.\n            spirals: {\n                'archimedean': archimedeanSpiral,\n                'rectangular': rectangularSpiral,\n                'square': squareSpiral\n            },\n            utils: {\n                extendPlayingField: extendPlayingField,\n                getRotation: getRotation,\n                isPolygonsColliding: isPolygonsColliding,\n                rotate2DToOrigin: rotate2DToOrigin,\n                rotate2DToPoint: rotate2DToPoint\n            }\n        });\n        SeriesRegistry.registerSeriesType('wordcloud', WordcloudSeries);\n        /* *\n         *\n         * Export Default\n         *\n         * */\n        /* *\n         *\n         * API Options\n         *\n         * */\n        /**\n         * A `wordcloud` series. If the [type](#series.wordcloud.type) option is not\n         * specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.wordcloud\n         * @exclude   dataSorting, boostThreshold, boostBlending\n         * @product   highcharts\n         * @requires  modules/wordcloud\n         * @apioption series.wordcloud\n         */\n        /**\n         * An array of data points for the series. For the `wordcloud` series type,\n         * points can be given in the following ways:\n         *\n         * 1. An array of arrays with 2 values. In this case, the values correspond to\n         *    `name,weight`.\n         *    ```js\n         *    data: [\n         *        ['Lorem', 4],\n         *        ['Ipsum', 1]\n         *    ]\n         *    ```\n         *\n         * 2. An array of objects with named values. The following snippet shows only a\n         *    few settings, see the complete options set below. If the total number of\n         *    data points exceeds the series'\n         *    [turboThreshold](#series.arearange.turboThreshold), this option is not\n         *    available.\n         *    ```js\n         *    data: [{\n         *        name: \"Lorem\",\n         *        weight: 4\n         *    }, {\n         *        name: \"Ipsum\",\n         *        weight: 1\n         *    }]\n         *    ```\n         *\n         * @type      {Array<Array<string,number>|*>}\n         * @extends   series.line.data\n         * @excluding drilldown, marker, x, y\n         * @product   highcharts\n         * @apioption series.wordcloud.data\n         */\n        /**\n         * The name decides the text for a word.\n         *\n         * @type      {string}\n         * @since     6.0.0\n         * @product   highcharts\n         * @apioption series.wordcloud.data.name\n         */\n        /**\n         * The weighting of a word. The weight decides the relative size of a word\n         * compared to the rest of the collection.\n         *\n         * @type      {number}\n         * @since     6.0.0\n         * @product   highcharts\n         * @apioption series.wordcloud.data.weight\n         */\n        ''; // detach doclets above\n\n        return WordcloudSeries;\n    });\n    _registerModule(_modules, 'masters/modules/wordcloud.src.js', [], function () {\n\n\n    });\n}));"],
  "mappings": ";;;;;;;AAQC,KAAA,SAAUA,GAAS;AACM,mBAAlB,OAAOC,UAAuBA,OAAAC,WAC9BF,EAAQ,SAAR,IAAqBA,GACrBC,OAAAC,UAAiBF,KACQ,eAAlB,OAAOG,UAAyBA,OAAAC,MACvCD,OAAO,gCAAgC,CAAC,YAAD,GAAgB,SAAUE,GAAY;AACzEL,UAAQK,CAAR;AACAL,UAAAK,aAAqBA;AACrB,eAAOL;MAHkE,CAA7E,IAMAA,EAA8B,gBAAtB,OAAOK,aAA6BA,aAAaC,MAAzD;IAXY,GAalB,SAAUD,GAAY;AAGpBE,eAASA,EAAgBC,IAAKC,GAAMC,GAAMC,GAAI;AACrCH,QAAAA,GAAAI,eAAmBH,CAAnB,MACDD,GAAIC,CAAJ,IAAYE,EAAAE,MAAS,MAAMH,CAAf,GAEe,eAAvB,OAAOI,eACPC,OAAAC,cACI,IAAIF,YACA,0BACA,EAAEG,QAAQ,EAAER,MAAMA,GAAMR,QAAQO,GAAIC,CAAJ,EAAtB,EAAV,CAFJ,CADJ;MALkC;AAD1CS,UAAWb,IAAaA,EAAAa,WAAsB,CAAA;AAelDX;QAAgBW;QAAU;QAAgC,CAACA,EAAS,mBAAT,CAAD;QAAiC,SAAUC,IAAG;AA6EpG,iBAJyBC,EACjBC,MApDRA,SAAcC,IAAOC,GAAQ;AAAA,gBACrBC,IAAoBD,EAAAC,mBACpBC,IAAaF,EAAAE,YACbC,IAAMH,EAAAG,KACNC,IAAWJ,EAAAI,UACXC,IAAaN,GAAAO,UAAgBP,GAAAO,OAAAC,MAAAC,cAEzB,SAECT,GAAAO,UACGP,GAAAO,OAAAG,QAAAJ,WACRK,IAAUX,GAAAW;AACdV,cAAAW,UAAiBX,EAAAW,WAAkB,CAAA;AAGnCX,cAAAW,QAAe,OAAf,IAA0BZ,GAAAa,aAAA;AAC1B,gBAAKb,GAAAc,WAAA;AACIH,oBACDX,GAAAW,UAAgBA,IAA+B,WAArBV,EAAAc,YACtBV,EAAAW,KAAA,IACAX,EAASJ,EAAAc,SAAT,EAA2Bd,EAAAgB,aAAoB,CAAA,CAA/C,GACJN,EAAAO,IAAYjB,EAAAkB,KAAZ,IAEAf,KACAO,EAAAP,IAAYA,CAAZ,GAEJO,EAAAS,KACUnB,EAAAW,OADV,EAAAS,QAEanB,GAAmBD,EAAAqB,QAAe,QAAQhB,GAAWH,CAFlE;qBAIKQ,GAAS;AACd,kBAAIY,KAAYA,WAAY;AACpBvB,gBAAAA,GAAAW,UAAgBA,IAAWA,KAAWA,EAAAa,QAAA;AAChB,+BAAtB,OAAOrB,KACPA,EAAA;cAHoB;AAOxBsB,qBAAAC,KAAYxB,CAAZ,EAAAyB,SACAhB,EAAAU,QAAgBnB,GAAmB,QAAQ,WAAY;AAAE,uBAAOqB,GAAA;cAAT,CAAvD,IAGAA,GAAA;YAZU;UA9BO,EAmDJzB;QAzE2E;MAAxG;AA+EAb,QAAgBW,GAAU,sCAAsC,CAACA,EAAS,+BAAT,GAA2CA,EAAS,mBAAT,CAA5C,GAA4E,SAAUgC,IAAgB/B,GAAG;AAYrK,YAAIgC,IAAa,QAAQ,KAAAA,aAAoB,2BAAY;AACjD,cAAIC,KAAgBA,SAAUC,GAClCC,IAAG;AACKF,YAAAA,KAAgBL,OAAAQ,kBACX,EAAEC,WAAW,CAAA,EAAb,aAA6BC,SAAS,SAAUJ,IAC7DC,IAAG;AAAED,cAAAA,GAAAG,YAAcF;YAAhB,KACS,SAAUD,IACtBC,IAAG;AAAE,uBAASI,KAAKJ;AAAOA,gBAAAA,GAAA1C,eAAiB8C,CAAjB,MAAqBL,GAAEK,CAAF,IAAOJ,GAAEI,CAAF;YAAnD;AACC,mBAAON,GAAcC,GAAGC,EAAjB;UANR;AAQH,iBAAO,SAAUD,IAAGC,IAAG;AAEnBK,qBAASA,IAAK;AAAE,mBAAAC,cAAmBP;YAArB;AADdD,YAAAA,GAAcC,IAAGC,EAAjB;AAEAD,YAAAA,GAAAQ,YAAoB,SAANP,KAAaP,OAAAe,OAAcR,EAAd,KAAoBK,EAAAE,YAAeP,GAAAO,WAAa,IAAIF;UAH5D;QAV8B,EAAb;AAiBxCI,YAAS5C,EAAA4C;AACTC,QAAAA,KAAgC,SAAUC,IAAQ;AAElDD,mBAASA,KAAiB;AAMtB,gBAAIE,KAAmB,SAAXD,MAAmBA,GAAApD,MAAa,MACxCsD,SAD2B,KACb;AAClBD,YAAAA,GAAAE,aAAmB;AACnBF,YAAAA,GAAAlC,UAAgB;AAChBkC,YAAAA,GAAAG,UAAgB;AAChBH,YAAAA,GAAAI,OAAa;AACbJ,YAAAA,GAAArC,SAAe;AACf,mBAAOqC;UAbe;AADtBf,YAAUa,IAAgBC,EAA1B;AAqBJD,UAAAA,GAAAH,UAAAU,UAAmCC,WAAY;AAC3C,mBAAO;UADoC;AAG/C,iBAAOR;QAzB2C,EAFpCd,GAAAuB,YAAAC,OAAAb,UAAAc,UAEkB;AA2BpCZ,UAAOC,GAAAH,WAA0B,EAC7Be,QAAQ,EADqB,CAAjC;AASA,eAAOZ;MAlE8J,CAAzK;AAoEAzD,QAAgBW,GAAU,sCAAsC,CAACA,EAAS,iBAAT,GAA6BA,EAAS,mBAAT,CAA9B,GAA8D,SAAU2D,IAAG1D,GAAG;AAuC1I2D,iBAASA,EAAyBC,GAAIC,GAAI;AACtC,iBAAO,EAAEA,EAAAC,OAAUF,EAAAG,SACfF,EAAAE,QAAWH,EAAAE,QACXD,EAAAG,MAASJ,EAAAK,UACTJ,EAAAI,SAAYL,EAAAI;QAJsB;AAkB1CE,iBAASA,GAAWC,GAAIC,GAAI;AAAA,cACpBC,IAAKD,EAAG,CAAH,IAAQD,EAAG,CAAH;AACbG,cAAKF,EAAG,CAAH,IAAQD,EAAG,CAAH;AACb,iBAAO,CACH,CAAC,CAACG,GACND,CADI,GAEA,CAACC,GAAI,CAACD,CAAN,CAHG;QAHa;AAY5BE,iBAASA,EAAmBrB,GAAS;AAAA,cAE7BsB,IAAOtB,EAAAsB,QAAgB,CAAA;AAC3B,cAAI,CAACA,EAAA1C,QAAa;AACd0C,gBAAO,CAAA;AACP,gBAAAC,IAASA,IAASvB,EAAAwB,OAAe,CAACxB,EAAQ,CAAR,CAAD,CAAf;AAClBuB,cAAAE,OAAcC,SAAkBT,IAAIC,IAAI;AACpC,kBAEIS,KAFUX,GAAWC,IACrBC,EADUU,EAEK,CAAR;AAEFC,gBAAKP,GACV,SAAUQ,IAAU;AAChB,uBAAOA,GAAS,CAAT,MAAgBH,GAAK,CAAL,KACnBG,GAAS,CAAT,MAAgBH,GAAK,CAAL;cAFJ,CADf,KAKLL,EAAAS,KAAUJ,EAAV;AAGJ,qBAAOT;YAb6B,CAAxC;AAeAlB,cAAAsB,OAAeA;UAlBD;AAoBlB,iBAAOA;QAvB0B;AAmCrCU,iBAASA,EAAQhC,GAASiC,GAAQ;AAC1BC,cAAWlC,EAAAmC,IAAY,SAAUlF,IAAO;AAKxC,mBAJaA,GAAM,CAANmF,IAERH,EAAO,CAAPI,IADApF,GAAM,CAANqF,IAEAL,EAAO,CAAPM;UAJmC,CAA7B;AAOf,iBAAO,EACHC,KAAKC,KAAAD,IAAAhG,MAAe,MAAM0F,CAArB,GACLQ,KAAKD,KAAAC,IAAAlG,MAAe,MAAM0F,CAArB,EAFF;QARuB;AAwClCS,iBAASA,EAAoBC,GAAUC,GAAU;AAAA,cAEzCC,IAAQzB,EAAmBuB,CAAnB,GACRG,KAAQ1B,EAAmBwB,CAAnB;AACRvB,cAAOwB,EAAAtB,OAAauB,EAAb;AAKX,iBAJ2BC,CAACnB,EAAKP,GAC7B,SAAUK,IAAM;AA9BuC,gBACvDsB,KAAcjB,EA8BdY,GADqDjB,EA7BvC;AAEduB,YAAAA,KAAclB,EA6Bda,GAFqDlB,EA3BvC;AA2BI,mBAvBf,CAFawB,EAAED,GAAAV,MAAkBS,GAAAP,OAChCQ,GAAAR,MAAkBO,GAAAT;UAwBN,CADQ;QALiB;AA0BjDY,iBAASA,EAAkBnG,GAAOsE,GAAQ;AAAA,cAClC8B,IAAa,OACbpD,KAAOhD,EAAAgD,MACPD,IAAU/C,EAAA+C,SACVsD,KAAmBrG,EAAAqG,kBACnBC,KAAiBA,SAAUlE,IAAG;AAC1B,gBAAImE,KAAS/C,EAAyBR,IAC1CZ,GAAAY,IADiB;AAEbuD,YAAAA,OACCvG,EAAAwG,WAAiB,MAAMpE,GAAAoE,WAAa,QACrCD,KAASb,EAAoB3C,GAASX,GAAAW,OAA7B;AAEb,mBAAOwD;UAPuB;AAY9BF,UAAAA,QACAD,IAAaE,GAAeD,EAAf,MAGT,OAAOrG,EAAAqG;AAKVD,gBACDA,IAAa,CAAC,CAACxB,EAAKN,GAAQ,SAAUlC,IAAG;AACrC,gBAAImE,KAASD,GAAelE,EAAf;AACTmE,YAAAA,OACAvG,EAAAqG,mBAAyBjE;AAE7B,mBAAOmE;UAL8B,CAA1B;AAQnB,iBAAOH;QAnC+B;AAsF1CK,iBAASA,EAAaC,GAASzG,GAAQ;AAC/B0G,cAAc,IAAVD;AAD2B,cAE/BE,IAAIpB,KAAAqB,MAAWrB,KAAAsB,KAAUH,CAAV,IAAe,KAAK,CAA/B,GACJI,KAAI,IAAIH,IAAI,GACZI,KAAIxB,KAAAyB,IAASF,IAAG,CAAZ,GAGLR,KAAS;AACZ,YAAAQ;AACe,iBAAXL,MAHwB,cAAb,OAIGH,MAAWI,KAAKK,KAAID,OAC9BR,KAAS,EACLW,GAAGN,KAAKI,KAAIL,IACZQ,GAAG,CAACP,EAFC,IAKbI,MAAKD,IAVmB,cAAb,OAWGR,MAAWI,KAAKK,KAAID,OAC9BR,KAAS,EACLW,GAAG,CAACN,GACJO,GAAG,CAACP,KAAKI,KAAIL,GAFR,IAKbK,MAAKD,IAjBmB,cAAb,OAkBGR,OAENA,KADAI,KAAKK,KAAID,KACA,EACLG,GAAG,CAACN,KAAKI,KAAIL,IACbQ,GAAGP,EAFE,IAMA,EACLM,GAAGN,GACHO,GAAGP,KAAKI,KAAIL,IAAII,IAFX,IAMjBR,GAAAW,KAAY,GACZX,GAAAY,KAAY;AAEhB,iBAAOZ;QAzC4B;AA8PvCa,iBAASA,EAAoBpE,GAAMqE,GAAO;AAGvB,cAAA,IAAAA,EAAAC,QAAc,GAChBC,KAAA,EAAEF,EAAAG,SAAe,IACdC,KAAAJ,EAAAG,SAAe;AAE/B,iBAAO,EALO7D,EAAE0D,EAAAC,QAAc,KAKDtE,EAAAW,QACzBC,IAAqBZ,EAAAY,SACrBC,KAAmBb,EAAAa,OACnBC,KAAsBd,EAAAc;QAVY;AAe1C4D,iBAASA,EAAYC,GAAQC,GAAQ7E,GAAS;AAC1C,iBAAOA,EAAAmC,IAAY,SAAUlF,IAAO;AAChC,mBAAO,CACHA,GAAM,CAAN,IAAW2H,GACX3H,GAAM,CAAN,IAAW4H,CAFR;UADyB,CAA7B;QADmC;AAwJ9CC,iBAASA,EAAaC,GAAQC,GAAW;AACjC3F,cAAI4F,EAASD,CAAT,IAAsBA,IAAY;AACtCE,cAAYzC,KAAAyB,IAAS,IACrB7E,CADY;AAEhB,iBAAOoD,KAAA0C,MAAWJ,IAASG,CAApB,IAAiCA;QAJH;AA6DzCE,iBAASA,EAAiBnI,GAAOoI,GAAO;AAAA,cAChClB,IAAIlH,EAAM,CAAN;AACJmH,cAAInH,EAAM,CAAN;AAF4B,cAGhCqI,KAAMC,IAAU,CAACF;AACjBG,cAAW/C,KAAAgD,IAASH,EAAT;eACA7C,KAAAiD,IAASJ,EAAT;AACf,iBAAO,CACHR,EAAaX,IAAIqB,IAAWpB,IAAIuB,EAAhC,GACAb,EAAaX,IAAIwB,KAAWvB,IAAIoB,CAAhC,CAFG;QAN6B;AAyBxCI,iBAASA,EAAgB3I,GAAO4I,GAAQR,GAAO;AAGvCS,cAAUV,EAAiB,CAFvBnI,EAAM,CAAN,IAAW4I,EAAO,CAAP,GACX5I,EAAM,CAAN,IAAW4I,EAAO,CAAP,CACY,GAE3BR,CAFU;AAGd,iBAAO,CACHS,EAAQ,CAAR,IAAaD,EAAO,CAAP,GACbC,EAAQ,CAAR,IAAaD,EAAO,CAAP,CAFV;QANoC;AA/uB/C,YAAIN,IAAU/E,GAAA+E,SACV7F,IAAS5C,EAAA4C,QACTmC,IAAO/E,EAAA+E,MACPoD,IAAWnI,EAAAmI,UACXc,IAAWjJ,EAAAiJ,UACXC,IAAQlJ,EAAAkJ;AA8wBZ,eApBqBC,EACbC,mBA7iBRA,SAA2BvC,GAASzG,GAAQ;AAAA,cACpCoH,IAAQpH,EAAAoH;AACRd,cAAS;AACT2C,cAAY7B,EAAAC,QAAcD,EAAAC,QAAgBD,EAAAG,SAAeH,EAAAG;AAF7D,cAGIT,KAAc,MAAVL;AAEW,iBAAXA,MACAH,IAAS,EACLW,GAAGH,KAAIvB,KAAAgD,IAASzB,EAAT,GACPI,GAAGJ,KAAIvB,KAAAiD,IAAS1B,EAAT,EAFF,GAIPvB,KAAAD,IAASC,KAAA2D,IAAS5C,EAAAW,CAAT,GAAoB1B,KAAA2D,IAAS5C,EAAAY,CAAT,CAA7B,IAAmD+B,MACrD3C,IAAS;AAGjB,iBAAOA;QAfiC,GA8iBpC6C,oBAlLRA,SAA4B/B,GAAOgC,GAAW;AAS1C,cAAIP,EAASzB,CAAT,KAAmByB,EAASO,CAAT,GAAqB;AACxC,gBAAA7B,IAAU6B,EAAAvF,SAAmBuF,EAAAxF;AAC7B,gBAAAyD,KAAS+B,EAAAzF,QAAkByF,EAAA1F;AAC3B2F,gBAASjC,EAAAiC;gBACTC,KAASlC,EAAAkC;AAETrC,gBAAMI,KAAQgC,IAAW9B,IAAS+B,KAAWjC,KAAQE;AAMrDjB,gBAASwC,EAAM1B,GAAO,EAElBC,OAAOD,EAAAC,QANGJ,IAAIoC,IAMsB,GAEpC9B,QAAQH,EAAAG,SAPGN,IAAIqC,KAOwB,EAJrB,CAAb;UAZ+B;AAuB5C,iBAAOhD;QAhCmC,GAmLtCiD,2BAhGRA,SAAmClF,GAAQ;AACvC,iBAAOA,EAAAE,OAAc,SAAUtF,IAAKc,GAAO;AAAA,gBACnCkH,IAAIlH,EAAM,CAAN;AACJmH,gBAAInH,EAAM,CAAN;AACRd,YAAAA,GAAAyE,OAAW6B,KAAAD,IAAS2B,GAAGhI,GAAAyE,IAAZ;AACXzE,YAAAA,GAAA0E,QAAY4B,KAAAC,IAASyB,GAAGhI,GAAA0E,KAAZ;AACZ1E,YAAAA,GAAA4E,SAAa0B,KAAAC,IAAS0B,GAAGjI,GAAA4E,MAAZ;AACb5E,YAAAA,GAAA2E,MAAU2B,KAAAD,IAAS4B,GAAGjI,GAAA2E,GAAZ;AACV,mBAAO3E;UAPgC,GAQxC,EACCyE,MAAM8F,OAAAC,WACN9F,OAAO,CAAC6F,OAAAC,WACR5F,QAAQ,CAAC2F,OAAAC,WACT7F,KAAK4F,OAAAC,UAJN,CARI;QADgC,GAiGnCC,iBAvYRA,SAAyBC,GAAaC,GAAcC,GAAM;AAClDC,cAAOD,EAAAtF,OAAY,SAAUtF,IAC7Bc,IAAO;AACC8C,YAAAA,KAAa9C,GAAA8C;AAAjB,gBACJoE,KAAI1B,KAAAC,IAAS3C,GAAAwE,OACbxE,GAAA0E,MADI;AAGJtI,YAAAA,GAAA8K,YAAgBxE,KAAAC,IAASvG,GAAA8K,WAAelH,GAAA0E,MAAxB;AAEhBtI,YAAAA,GAAA+K,WAAezE,KAAAC,IAASvG,GAAA+K,UAAcnH,GAAAwE,KAAvB;AAEfpI,YAAAA,GAAAgL,QAAYhD,KAAIA;AAChB,mBAAOhI;UAVA,GAWR,EACC8K,WAAW,GACXC,UAAU,GACVC,MAAM,EAHP,CAZQ;AAqBXhD,cAAI1B,KAAAC,IAASsE,EAAAC,WACbD,EAAAE,UAEuB,OAAvBzE,KAAAsB,KAAUiD,EAAAG,IAAV,CAHI;AAtBkD,cAyBxBZ,KAASM,IAAcC,IAAeD,IAAcC,IAAe;AAAGN,cAASM,IAAeD,IAAcC,IAAeD,IAAc;AACvK,iBAAO,EACHtC,OAAOJ,IAAIoC,IACX9B,QAAQN,IAAIqC,GACZD,QAAQA,IACRC,QAAQA,EAJL;QA1B+C,GAwYlDY,YA/ERA,SAAoBjD,GAAGC,GAAGG,GAAOE,IAAQhB,IAAU;AAAA,cAC3CoC,KAAS,CAAC1B,GACVC,CADS,GAETxD,KAAOuD,IAAKI,IAAQ;AACZJ,eAAKI,IAAQ;AACrBzD,cAAMsD,IAAKK,KAAS;AACXL,eAAKK,KAAS;AAW3B,iBAVczE,CACN,CAACY,IACLE,CADI,GAEA,CAACD,GACLC,CADI,GAEA,CAACD,GACLE,CADI,GAEA,CAACH,IACLG,CADI,CAPMf,EAUPmC,IAAY,SAAUlF,IAAO;AAChC,mBAAO2I,EAAgB3I,IAAO4I,IAAQ,CAACpC,EAAhC;UADyB,CAA7B;QAjBwC,GAgF3C4D,mBAlcRA,SAA2BC,GAAM;AAC7B,iBAAO7E,KAAA0C,MAAYmC,KAAQ7E,KAAA8E,OAAA,IAAgB,OAAQ,CAA5C;QADsB,GAmczBC,aAlVRA,SAAqBC,GAAcC,GAAOC,GAAMC,IAAI;AAAA,cAC5CpE,KAAS;AAKTyB,YAASwC,CAAT,KACAxC,EAASyC,CAAT,KACAzC,EAAS0C,CAAT,KACA1C,EAAS2C,EAAT,KACe,IAAfH,KACQ,KAARC,KACAE,KAAKD,MAILnE,KAASmE,IADKD,IAAQD,MAFdG,KAAKD,MACQF,IAAe,KAAK;AAI7C,iBAAOjE;QAlByC,GAmV5CqE,UA3aRA,SAAkBhB,GAAaC,GAAcxC,GAAO;AAAA,cAC5CG,KAC0B,IADjBhC,KAAAC,IAASD,KAAA2D,IAAS9B,EAAAxD,GAAT,GAClB2B,KAAA2D,IAAS9B,EAAAvD,MAAT,CADS;AAETwD,cACyB,IADjB9B,KAAAC,IAASD,KAAA2D,IAAS9B,EAAA1D,IAAT,GACjB6B,KAAA2D,IAAS9B,EAAAzD,KAAT,CADQ;AAIZ,iBAAO4B,KAAAD,IAFc,IAAR+B,IAAY,IAAIA,IAAQsC,IAAc,GAC7B,IAATpC,KAAa,IAAIA,KAASqC,IAAe,CAC/C;QAPyC,GA4a5CgB,WAjTRA,SAAmBxL,GAAIY,GAAQ;AAAA,cAEvB6K,IACAC,KAAM,CAAA;AACV,eAAKD,KAAI,GAHInJ,MAGDmJ,IAAYA;AAEpBC,YAAAA,GAAAjG,KAASzF,EAAGyL,IAAG7K,CAAN,CAAT;AAEJ,iBAAO,SAAUyG,IAAS;AACtB,mBARS/E,OAQF+E,KAAoBqE,GAAIrE,KAAU,CAAd,IAAmB;UADxB;QARC,GAkTvBsE,qBA9ORA,SAA6BhL,GAAOU,GAAS;AAAA,cACrCuK,KAASvK,EAAAuK,QACT5D,KAAQ3G,EAAA2G,OACRgC,KAAY3I,EAAA2I,WACZtG,KAAUrC,EAAAqC,SACVmI,KAASxK,EAAAwK,QACTxE,KAAU,GACVyE,KAAQ,EACJjE,GAAG,GACHC,GAAG,EAFC,GAKRnE,KAAOhD,EAAAgD,OAAaP,EAAO,CAAA,GAC3B4G,EADoB;AAExBrJ,YAAA+C,UAAgBA;AAOhB,eANA/C,EAAAwG,WAAiB9F,EAAA8F,UAMA,UAAV2E,OACFhF,EAAkBnG,GAAOiL,EAAzB,KACG7D,EAAoBpE,IAAMqE,EAA1B;AACJ8D,YAAAA,KAAQD,GAAOxE,EAAP,GACJoC,EAASqC,EAAT,MAEAnI,GAAAW,OAAY0F,GAAA1F,OAAiBwH,GAAAjE,GAC7BlE,GAAAY,QAAayF,GAAAzF,QAAkBuH,GAAAjE,GAC/BlE,GAAAa,MAAWwF,GAAAxF,MAAgBsH,GAAAhE,GAC3BnE,GAAAc,SAAcuF,GAAAvF,SAAmBqH,GAAAhE,GACjCnH,EAAA+C,UAAgB2E,EAAYyD,GAAAjE,GAASiE,GAAAhE,GAASpE,EAA9B,IAEpB2D;AAEJ,iBAAOyE;QAnCkC,GA+OrCzF,qBAAqBA,GACrBlC,0BAA0BA,GAC1B4H,mBA7dRA,SAA2B1E,GAASzG,GAAQ;AACpCsG,cAASE,EAAaC,GACtBzG,CADS;AAEToH,cAAQpH,EAAAoH;AACRd,gBACAA,EAAAW,KAAYG,EAAAiC,QACZ/C,EAAAY,KAAYE,EAAAkC;AAEhB,iBAAOhD;QARiC,GA8dpC4B,kBAAkBA,GAClBQ,iBAAiBA,GACjBlC,cAAcA,GACd4E,uBA9IRA,SAA+BhE,GAAOgC,GAAW;AAE7C,cAAI,CAACrB,EAASX,EAAA1D,IAAT,KAAwB0D,EAAA1D,OAAa0F,EAAA1F;AACtC0D,cAAA1D,OAAa0F,EAAA1F;AAEjB,cAAI,CAACqE,EAASX,EAAAzD,KAAT,KAAyByD,EAAAzD,QAAcyF,EAAAzF;AACxCyD,cAAAzD,QAAcyF,EAAAzF;cAEd,CAACoE,EAASX,EAAAxD,GAAT,KAAuBwD,EAAAxD,MAAYwF,EAAAxF;AACpCwD,cAAAxD,MAAYwF,EAAAxF;AAEhB,cAAI,CAACmE,EAASX,EAAAvD,MAAT,KAA0BuD,EAAAvD,SAAeuF,EAAAvF;AAC1CuD,cAAAvD,SAAeuF,EAAAvF;AAEnB,iBAAOuD;QAdsC,EA6H5B2B;MA3wBqH,CAA9I;AAiyBA/J,QAAgBW,GAAU,uCAAuC,CAACA,EAAS,8BAAT,GAA0CA,EAAS,iBAAT,GAA6BA,EAAS,uBAAT,GAAmCA,EAAS,+BAAT,GAA2CA,EAAS,mBAAT,GAA+BA,EAAS,oCAAT,GAAgDA,EAAS,oCAAT,CAArO,GAAsR,SAAU0L,IAAK/H,GAAGgI,GAAQ3J,IAAgB/B,GAAG6C,GAAgBsG,GAAgB;AAYha,YAAInH,IAAa,QAAQ,KAAAA,aAAoB,2BAAY;AACjD,cAAIC,KAAgBA,SAAUC,IAClCC,IAAG;AACKF,YAAAA,KAAgBL,OAAAQ,kBACX,EAAEC,WAAW,CAAA,EAAb,aAA6BC,SAAS,SAAUJ,IAC7DC,IAAG;AAAED,cAAAA,GAAAG,YAAcF;YAAhB,KACS,SAAUD,IACtBC,IAAG;AAAE,uBAASI,MAAKJ;AAAOA,gBAAAA,GAAA1C,eAAiB8C,EAAjB,MAAqBL,GAAEK,EAAF,IAAOJ,GAAEI,EAAF;YAAnD;AACC,mBAAON,GAAcC,IAAGC,EAAjB;UANR;AAQH,iBAAO,SAAUD,IAAGC,IAAG;AAEnBK,qBAASA,KAAK;AAAE,mBAAAC,cAAmBP;YAArB;AADdD,YAAAA,GAAcC,IAAGC,EAAjB;AAEAD,YAAAA,GAAAQ,YAAoB,SAANP,KAAaP,OAAAe,OAAcR,EAAd,KAAoBK,GAAAE,YAAeP,GAAAO,WAAa,IAAIF;UAH5D;QAV8B,EAAb,GAgBxCmJ,IAAOjI,EAAAiI,MACPC,IAAe7J,GAAAuB,YAAAC,QACfX,IAAS5C,EAAA4C,QACTiJ,IAAU7L,EAAA6L,SACV1D,IAAWnI,EAAAmI,UACXc,IAAWjJ,EAAAiJ,UACXC,IAAQlJ,EAAAkJ;AACRE,YAAoBD,EAAAC;AAnCwY,YAoC5ZG,IAAqBJ,EAAAI,oBACrBI,IAA4BR,EAAAQ,2BAC5BG,IAAkBX,EAAAW,iBAClBQ,IAAanB,EAAAmB,YACbC,IAAoBpB,EAAAoB,mBACpBG,IAAcvB,EAAAuB,aACdK,IAAW5B,EAAA4B,UACXC,IAAY7B,EAAA6B,WACZG,IAAsBhC,EAAAgC,qBACtBtF,IAAsBsD,EAAAtD,qBACtB0F,IAAoBpC,EAAAoC,mBACpBjD,IAAmBa,EAAAb,kBACnBQ,IAAkBK,EAAAL,iBAClBlC,IAAeuC,EAAAvC,cACf4E,IAAwBrC,EAAAqC;AAaxBM,YAAiC,SAAUhJ,IAAQ;AAEnDgJ,mBAASA,KAAkB;AAMvB,gBAAI/I,KAAmB,SAAXD,MAAmBA,GAAApD,MAAa,MACxCsD,SAD2B,KACb;AAMlBD,YAAAA,GAAAkH,OAAa;AACblH,YAAAA,GAAAlC,UAAgB;AAChBkC,YAAAA,GAAA0B,SAAe;AACf,mBAAO1B;UAhBgB;AADvBf,YAAU8J,IAAiBhJ,EAA3B;AAwBJgJ,UAAAA,GAAApJ,UAAAqJ,WAAqCC,WAAY;AAC7C,gBAAIC,KAAgB,EACZC,WAAW,OACXC,eAAe,GACfC,WAAW,GACXC,YAAY,GACZC,aAAa,OACbC,OAAO,QACPC,eAAe,CAAA,EAPH;AASpBd,cAAAhJ,UAAAqJ,SAAAU,KAA+B,IAA/B;AACA7J,cAAO,KAAA8J,MAAA7L,SAAoBoL,EAA3B;AACArJ;cAAO,KAAA+J,MAAA9L;cAAoBoL;YAA3B;UAZ6C;AAcjDH,UAAAA,GAAApJ,UAAAkK,eAAyCC,SAAU1M,IAAO2M,IAAO;AACzD/L,YAAAA,KAAU2C,EAAAJ,YAAAC,OAAAb,UAAAkK,aAAAH,KACa,MACvBtM,IACA2M,EAHU;AAId,mBAAO/L,GAAAgM;AACP,mBAAOhM,GAAQ,cAAR;AACP,mBAAOA;UAPsD;AA4BjE+K,UAAAA,GAAApJ,UAAAsK,iBAA2CC,SAAUC,IAAgBC,IAAaC,IAAa;AACvF3J,YAAAA,KAAS0E,EAAS+E,EAAT,IAA2BA,KAAiB;AACrDtH,YAAAA,KAAMuC,EAASgF,EAAT,IAAwBA,KAAc;AAC5CzH,YAAAA,KAAMyC,EAASiF,EAAT,IAAwBA,KAAc;AAChD,mBAAOzH,KAAA0H,MAAW1H,KAAAC,IAASF,IAAKjC,KAASmC,EAAvB,CAAX;UAJoF;AAM/FkG,UAAAA,GAAApJ,UAAA4K,aAAuCC,WAAY;AAAA,gBAC3C7M,KAAS,MACTE,KAAcF,GAAAE,aACd+L,KAAQjM,GAAAiM,OACRD,KAAQhM,GAAAgM,OAERpL,KAAQZ,GAAAY,OACRT,KAAUH,GAAAG,SACVJ,KAAYI,GAAAJ,WACZ+M,IAA0B3M,GAAA2M,yBAC1BhN,KALQE,GAAAC,MAKGH,UACXiN,KAAcjN,GAAAW,KAAA,EAAAE,IAAoBC,EAApB,GACd8J,KAAS,CAAA,GACTsC,KAAoBhN,GAAAgN,kBAAyB7M,GAAA6M,iBAAzB,GAEpB/G,KAAW9F,GAAA8F,UAEXgH,KAAUjN,GAAA+D,OAAAY,IAAkB,SAAU9C,IAAG;AACrC,qBAAOA,GAAAkB;YAD8B,CAA/B,GAEVmK,KAAYjI,KAAAC,IAAAlG,MAAe,MAAMiO,EAArB,GAEhB1D,IAAOvJ,GAAA+D,OAAAC,OAAA,EAAAmJ,KAA4B,SAAU/G,IAAG3E,IAAG;AAC/C,qBAAOA,GAAAsB,SAAWqD,GAAArD;YAD6B,CAA5C;AAQP/C,YAAAA,GAAAY,MAAAC,KAAkB,EACduM,QAAQ,GACRC,QAAQ,EAFM,CAAlB;AAMA9D,cAAA+D,QAAa,SAAU7N,IAAO;AAAA,kBAEtB8N,KAAWvN,GAAAsM,eADM,IAAIY,KAAYzN,GAAAsD,QAEjC5C,GAAAsM,aACAtM,GAAAuM,WAFW;AAGX7M,cAAAA,KAAMqC,EAAO,EACTqL,UAAUA,KAAW,KADZ,GAGbpN,GAAAqN,KAHM;AAKVT,cAAAA,GAAAlN,IAAgBA,EAAhB,EAAAgB,KAA0B,EACtB8F,GAAG,GACHC,GAAG,GACHnG,MAAMhB,GAAAgO,KAHgB,CAA1B;AAKAC,cAAAA,KAAOX,GAAAY,QAAoB,IAApB;AACPlO,cAAAA,GAAA8C,aAAmB,EACf0E,QAAQyG,GAAAzG,QACRF,OAAO2G,GAAA3G,MAFQ;YAhBO,CAA9B;AAsBA,gBAAAD,IAAQsC,EAAgB6C,GAAA2B,KAAW5B,GAAA4B,KAAWrE,CAAtC;AACR,gBAAAoB,IAASL,EAAUtK,GAAA6N,QAAe1N,GAAAwK,MAAf,GAAgC,EAC/C7D,OAAOA,EADwC,CAA1C;AAITyC,cAAA+D,QAAa,SAAU7N,IAAO;AAAA,kBAEtB8N,KAAWvN,GAAAsM;gBADM,IAAIY,KAAYzN,GAAAsD;gBAEjC5C,GAAAsM;gBACAtM,GAAAuM;cAFW;AAGX7M,cAAAA,KAAMqC,EAAO,EACTqL,UAAUA,KAAW,KADZ,GAGbpN,GAAAqN,KAHM;AALgB,kBAStBM,KAAYd,GAAkBvN,IAAO,EACjC8J,MAAMA,GACNzC,OAAOA,GACP4D,QAAQA,IACRzE,UAAUA,GAJuB,CAAzB,GAMZpF,KAAOqB,EAAOlC,GAAAkM,aAAoBzM,IAAQA,GAAAsO,YAAkB,QAA9C,GAA0D,EACpEC,OAAO,UACP,sBAAsB,UACtB,qBAAqB,UACrBrH,GAAGmH,GAAAnH,GACHC,GAAGkH,GAAAlH,GACHnG,MAAMhB,GAAAgO,MACNxH,UAAUwB,EAASqG,GAAA7H,QAAT,IACN6H,GAAA7H,WACA,OATgE,CAAjE,GAWPzD,KAAUoH,EAAWkE,GAAAnH,GACrBmH,GAAAlH,GACAnH,GAAA8C,WAAAwE,OACAtH,GAAA8C,WAAA0E,QACA6G,GAAA7H,QAJU,GAKV6C,KAAYG,EAA0BzG,EAA1B,GACZoI,IAAQH,EAAoBhL,IAAO,EAC/BqJ,WAAWA,IACXtG,SAASA,IACTsE,OAAOA,GACP4D,QAAQA,IACRC,QAAQA,GACR1E,UAAU6H,GAAA7H,SANqB,CAA3B;AAUR,eAAC2E,KAASkC,MAEVhG,IAAQ+B,EAAmB/B,GAAOgC,EAA1B,GAER8B,IAAQH,EAAoBhL,IAAO;gBAC/BqJ,WAAWA;gBACXtG,SAASA;gBACTsE,OAAOA;gBACP4D,QAAQA;gBACRC,QAAQA;gBACR1E,UAAU6H,GAAA7H;cANqB,CAA3B;AAWRsC,gBAASqC,CAAT,KACA/J,GAAA8F,KAAU9F,GAAA8F,KAAU,KAAKiE,EAAAjE,GACzB9F,GAAA+F,KAAU/F,GAAA+F,KAAU,KAAKgE,EAAAhE,GACzBkC,GAAA1F,QAAkBwH,EAAAjE,GAClBmC,GAAAzF,SAAmBuH,EAAAjE,GACnBmC,GAAAxF,OAAiBsH,EAAAhE,GACjBkC,GAAAvF,UAAoBqH,EAAAhE,GACpBE,IAAQgE,EAAsBhE,GAAOgC,EAA7B,GACR4B,GAAAnG,KAAY9E,EAAZ,GACAA,GAAAwO,SAAe,OACfxO,GAAAyO,WAAiB,QAGjBzO,GAAAwO,SAAe;AAEnB,kBAAIlO,IAAW;AAEX,oBAAAe,IAAU,EACN6F,GAAG9F,GAAA8F,GACHC,GAAG/F,GAAA+F,EAFG;AAKL1G,gBAAAA,MAMD,OAAOW,GAAA8F,GACP,OAAO9F,GAAA+F,MANP/F,GAAA8F,IAAS,GACT9F,GAAA+F,IAAS;cATF;AAiBfmE,cAAAA,GAAAvL,KAASC,IAAO,EACZE,mBAAmBmB,GACnBT,SAASQ,IACThB,KAAKA,IACLe,OAAOA,IACPd,UAAUA,IACVY,WAAW,QACXF,WAAW,OAPC,CAAhB;YAzF0B,CAA9B;AAoGAuM,YAAAA,KAAcA,GAAA9L,QAAA;AAEdkN,YAAAA,KAAQ9D,EAAS4B,GAAA2B,KAAW5B,GAAA4B,KAAW9G,CAA/B;AACR9G,YAAAA,GAAAY,MAAAC,KAAkB,EACduM,QAAQe,IACRd,QAAQc,GAFM,CAAlB;UArK+C;AA0KnD/C,UAAAA,GAAApJ,UAAAoM,UAAoCC,WAAY;AAE5C,mBAAQ9F,EADKvI,IACL,KACe,SAFVA,KAETsO,WACAnD,EAHSnL,KAGD+D,MAAR,KACuB,IAJd/D,KAIT+D,OAAA3C;UALwC;AAOhDgK,UAAAA,GAAApJ,UAAAuM,aAAuCC,WAAY;AAAA,gBAC5BvO,KAAND,KAAcC,OAAcwO,KAAWxO,GAAAwO,UAEhDxC,KAFSjM,KAEOyO,KAAW,UAAU,OAA7B;AAAwCzC,YAAAA,KAFvChM,KAEuDyO,KAAW,UAAU,OAA7B;AAC5D,mBAAO,EACHC,aAFgMzC,KAAQA,GAAA7I,OAAanD,GAAA0O,aAA7G1C,KAAQA,GAAA2B,MAAY3N,GAAA2O,aAEnG,GACzBC,aAHyO7C,KAAQA,GAAA1I,MAAYrD,GAAA6O,YAAvG9C,KAAQA,GAAA4B,MAAY3N,GAAA8O,cAGhJ,GAC1B3B,QAAQ,GACRC,QAAQ,EAJL;UAJwC;AAiCnDjC,UAAAA,GAAA4D,iBAAiCxG,EAAM0C,EAAA8D,gBAA6B,EAWhElC,yBAAyB,MACzB/M,WAAW,EAEPkP,UAAU,IAFH,GAIXC,aAAa,GAIbC,MAAM,OACNC,cAAc,MACdC,eAAeC,UAKf5C,aAAa,GAObD,aAAa,IAWbO,mBAAmB,UAOnB/G,UAAU;YAINkE,MAAM;YAMNF,cAAc;YAIdG,IAAI;UAdE,GAgBVmF,cAAc,OAUd5E,QAAQ,eAOR6C,OAAO,EAEHgC,YAAY,cAEZC,YAAY,OAEZC,YAAY,SANT,GAQPC,SAAS,EACLC,eAAe,MACfC,aAAa,uFAFR,EA7FuD,CAAnC;AAkGjC,iBAAOzE;QA7X4C,EA8XrDF,CA9XmC;AA+XrChJ,UAAOkJ,EAAApJ,WAA2B,EAC9BlB,SAASmK,GACT6E,kBAAkB7E,GAClB8E,oBAAoB9E,GACpBnI,YAAYX,GACZ6N,SAAS/E,GAIT+B,mBAAmB,EACfjD,QAAQA,SAAUtK,IAAOU,IAAS;AAAA,cAC1B2G,KAAQ3G,GAAA2G;AACRmJ,UAAAA,KAAI9P,GAAA8F;AACR,iBAAO,EACHU,GAAGkD,EAAkB/C,GAAAC,KAAlB,IAAkCD,GAAAC,QAAc,GACnDH,GAAGiD,EAAkB/C,GAAAG,MAAlB,IAAmCH,GAAAG,SAAe,GACrDhB,UAAU+D;YAAYiG,GAAAhG;YAAgBxK,GAAAyK;YAAa+F,GAAA9F;YAAQ8F,GAAA7F;UAAjD,EAHP;QAHuB,GASlC8F,QAAQA,SAAUzQ,IAAOU,IAAS;AAC1B8P,UAAAA,KAAI9P,GAAA8F;AACR,iBAAO,EACHU,GAAG,GACHC,GAAG,GACHX,UAAU+D,EAAYiG,GAAAhG,cAAgBxK,GAAAyK,OAAa+F,GAAA9F,MAAQ8F,GAAA7F,EAAjD,EAHP;QAFuB,EAVnB,GAmBnB+F,eAAe,CAAC,QAAD,GAIftC,SAAS,EACL,aAAenF,GACf,aAAemC,GACf,QAAU3E,EAHL,GAKTkK,OAAO,EACHvH,oBAAoBA,GACpBmB,aAAaA,GACb7E,qBAAqBA,GACrByC,kBAAkBA,GAClBQ,iBAAiBA,EALd,EArCuB,CAAlC;AA6CA/G,QAAAA,GAAAgP,mBAAkC,aAAajF,CAA/C;AAwEA;AAEA,eAAOA;MArjByZ,CAApa;AAujBA1M,QAAgBW,GAAU,oCAAoC,CAAA,GAAI,WAAY;MAAA,CAA9E;IA5/CoB,CAbvB;;;",
  "names": ["factory", "module", "exports", "define", "amd", "Highcharts", "undefined", "_registerModule", "obj", "path", "args", "fn", "hasOwnProperty", "apply", "CustomEvent", "window", "dispatchEvent", "detail", "_modules", "U", "DrawPointUtilities", "draw", "point", "params", "animatableAttribs", "onComplete", "css", "renderer", "animation", "series", "chart", "hasRendered", "options", "graphic", "attribs", "getClassName", "shouldDraw", "shapeType", "text", "shapeArgs", "add", "group", "attr", "animate", "isNew", "destroy_1", "destroy", "Object", "keys", "length", "SeriesRegistry", "__extends", "extendStatics", "d", "b", "setPrototypeOf", "__proto__", "Array", "p", "__", "constructor", "prototype", "create", "extend", "WordcloudPoint", "_super", "_this", "arguments", "dimensions", "polygon", "rect", "isValid", "WordcloudPoint.prototype.isValid", "seriesTypes", "column", "pointClass", "weight", "H", "isRectanglesIntersecting", "r1", "r2", "left", "right", "top", "bottom", "getNormals", "p1", "p2", "dx", "dy", "getAxesFromPolygon", "axes", "points", "concat", "reduce", "findAxis", "axis", "normals", "find", "existing", "push", "project", "target", "products", "map", "ax", "bx", "ay", "by", "min", "Math", "max", "isPolygonsColliding", "polygon1", "polygon2", "axes1", "axes2", "overlappingOnAllAxes", "projection1", "projection2", "isOverlapping", "intersectsAnyWord", "intersects", "lastCollidedWith", "isIntersecting", "result", "rotation", "squareSpiral", "attempt", "a", "k", "ceil", "sqrt", "t", "m", "pow", "x", "y", "outsidePlayingField", "field", "width", "c", "height", "f", "movePolygon", "deltaX", "deltaY", "correctFloat", "number", "precision", "isNumber", "magnitude", "round", "rotate2DToOrigin", "angle", "rad", "deg2rad", "cosAngle", "cos", "sin", "sinAngle", "rotate2DToPoint", "origin", "rotated", "isObject", "merge", "WordcloudUtils", "archimedeanSpiral", "maxDelta", "abs", "extendPlayingField", "rectangle", "ratioX", "ratioY", "getBoundingBoxFromPolygon", "Number", "MAX_VALUE", "getPlayingField", "targetWidth", "targetHeight", "data", "info", "maxHeight", "maxWidth", "area", "getPolygon", "getRandomPosition", "size", "random", "getRotation", "orientations", "index", "from", "to", "getScale", "getSpiral", "i", "arr", "intersectionTesting", "placed", "spiral", "delta", "rectangularSpiral", "updateFieldBoundaries", "DPU", "Series", "noop", "ColumnSeries", "isArray", "WordcloudSeries", "bindAxes", "WordcloudSeries.prototype.bindAxes", "wordcloudAxis", "endOnTick", "gridLineWidth", "lineWidth", "maxPadding", "startOnTick", "title", "tickPositions", "call", "yAxis", "xAxis", "pointAttribs", "WordcloudSeries.prototype.pointAttribs", "state", "stroke", "deriveFontSize", "WordcloudSeries.prototype.deriveFontSize", "relativeWeight", "maxFontSize", "minFontSize", "floor", "drawPoints", "WordcloudSeries.prototype.drawPoints", "allowExtendPlayingField", "testElement", "placementStrategy", "weights", "maxWeight", "sort", "scaleX", "scaleY", "forEach", "fontSize", "style", "name", "bBox", "getBBox", "len", "spirals", "placement", "selected", "align", "isNull", "isInside", "scale", "hasData", "WordcloudSeries.prototype.hasData", "visible", "getPlotBox", "WordcloudSeries.prototype.getPlotBox", "inverted", "translateX", "plotLeft", "plotWidth", "translateY", "plotTop", "plotHeight", "defaultOptions", "duration", "borderWidth", "clip", "colorByPoint", "cropThreshold", "Infinity", "showInLegend", "fontFamily", "fontWeight", "whiteSpace", "tooltip", "followPointer", "pointFormat", "animateDrilldown", "animateDrillupFrom", "setClip", "r", "center", "pointArrayMap", "utils", "registerSeriesType"]
}
